//
// Definition
//

type big_array<a> = list<a>;

//
// Empty constructor 
//
export const construct : <T>((p: [nat, T]) => big_array<option<T>>) = ([size, wanted_type] : [nat, T]) : big_array<option<T>> => {
  let construct_rec : <T>((pp: [nat, T, big_array<option<T>>]) => big_array<option<T>>) = ([size, wanted_type, res] : [nat, T, big_array<option<T>>]) : big_array<option<T>> => {
    if (size == (0 as nat)) { 
      return res;
    } else {
      return construct_rec( [(abs(size - (1 as nat))), wanted_type, (list([(None() as option<T>), ...res]))] )
    };
  };
  return construct_rec( [size, wanted_type, (list([]) as big_array<option<T>>)] );
};

//
// Last retrieves the last element 
//
export const last : <T>((p: big_array<T>) => T) = (lst1 : big_array<T>) : T => {
  let last_rec : <T>((pp: big_array<T>) => T) = (lst1 : big_array<T>) : T => {
    match(lst1, list([ 
    ( [] : big_array<T>) => failwith("The big_array is empty"),
    ( [hd1, ...tl1] : big_array<T>) => { 
        return match(tl1, list([
        ( [] : big_array<T>) => hd1,
        ( [_hd2, ..._tl2] : big_array<T>) => last_rec (tl1)
        ]));
    }
    ])); 
  };
  return last_rec (lst1);
};

//
// Reversing
//
export const reverse : <T>((p: big_array<T>) => big_array<T>) = (lst1 : big_array<T>) : big_array<T> => {
  let reverse_rec : <T>((pp: [big_array<T>, big_array<T>]) => big_array<T>) = ([lst1, res] : [big_array<T>, big_array<T>]) : big_array<T> =>
    match(lst1, list([
    ( [] : big_array<T>) => res,
    ( [hd1, ...tl1] : big_array<T>) => reverse_rec([tl1, list([hd1, ...res])]) 
    ]));
  return reverse_rec([lst1, (list([]) as big_array<T>)]);
};

//
// Concatenation
//
export const concat : <T>((p: [big_array<T>, big_array<T>]) => big_array<T>) = ([lst1, lst2] : [big_array<T>, big_array<T>]) : big_array<T> => {
  let concat_rec : <T>((pp: [big_array<T>, big_array<T>]) => big_array<T>) = ([lst1r, lst2] : [big_array<T>, big_array<T>]) : big_array<T> =>
    match(lst1r, list([
    ( [] : big_array<T>) => lst2,
    ( [hd1, ...tl1] : big_array<T>) => concat_rec([tl1, list([hd1, ...lst2])])
    ]));
  let lst1r : big_array<T> = reverse(lst1);
  return concat_rec( [(lst1r as big_array<T>), lst2] );
};

//
// Get an element by his number position
//
export const find : <T>((p: [nat, big_array<T>]) => T) = ([position, lst1] : [nat, big_array<T>]) : T => {
  let get : <T>((p: [nat, big_array<T>]) => T) = ([position, lst1] : [nat, big_array<T>]) : T => {
    match(lst1, list([
    ( [] : big_array<T>) => failwith("Position is highter than big_array length"),
    ( [hd1, ...tl1] : big_array<T>) => {
      if (position == (0 as nat)) { return hd1 } 
      else { return get ( [abs(position - (1 as nat)), tl1 ] ) }
    }
    ]));
  };
  return get ([position, lst1])
};

//
// Set an element by his number position
//
export const set : <T>((p: [T, nat, big_array<T>]) => big_array<T>) = ([element, position, lst1] : [T, nat, big_array<T>]) : big_array<T> => {
  let set_ : <T>((p: [T, nat, big_array<T>, big_array<T>]) => big_array<T>) = ([element, position, lst1, res] : [T, nat, big_array<T>, big_array<T>]) : big_array<T> =>
    match(lst1, list([
    ( [] : big_array<T>) => failwith("Position is highter than big_array length"),
    ( [hd1, ...tl1] : big_array<T>) => {
        if (position == (0 as nat)) { 
          let lst2 : big_array<T> = reverse( list([element, ...res]) );
          return concat((lst2 as big_array<T>), tl1);
        }
        else { 
          return set_ ([element, abs(position - (1 as nat)), tl1, list([hd1, ...res])]) 
        } 
      }
    ]));
  return set_ ([element, position, lst1, (list([]) as big_array<T>)]);
};

//
// Insertion
//
export const insert :  <T>((p: [T, nat, big_array<T>]) => big_array<T>) = ([element, position, lst1] : [T, nat, big_array<T>]) : big_array<T> => {
  let insert_rec : <T>((p: [T, nat, big_array<T>, big_array<T>]) => big_array<T>) = ([element, position, lst1, lst2] : [T, nat, big_array<T>, big_array<T>]) : big_array<T> =>
    match(lst1, list([ 
    ( [] : big_array<T>) => failwith("Position is highter than big_array length"),
    ( [hd1, ...tl1] : big_array<T>) => {
      if (position == (0 as nat)) {
        let lst3 : big_array<T> = list([element, ...lst2]);
        let lst4 : big_array<T> = reverse((lst3 as big_array<T>));
        return concat((lst4 as big_array<T>), lst1);
      }
      else {
        return insert_rec( [element, abs(position - (1 as nat)), tl1, list([hd1, ...lst2])] );
      }
    }
    ]));
  return insert_rec( [element, position, lst1, (list([]) as big_array<T>)] );
};

//
// Drop the element at a specific position
//
export const drop : <T>((p: [nat, big_array<T>]) => big_array<T>) = ([position, lst1] : [nat, big_array<T>]) : big_array<T> => {
  let drop_rec : <T>((p: [nat, big_array<T>, big_array<T>]) => big_array<T>) = ([position, lst1, lst2] : [nat, big_array<T>, big_array<T>]) : big_array<T> =>
    match(lst1, list([ 
    ( [] : big_array<T>) => failwith("Position is highter than big_array length"),
    ( [hd1, ...tl1] : big_array<T>) => { 
        if (position == (0 as nat)) {
          let lst3 : big_array<T> = reverse(lst2); 
          return concat((lst3 as big_array<T>), tl1);
        } else {
          return drop_rec( [abs(position - (1 as nat)), tl1, list([hd1, ...lst2])] );
        }
      }
    ]));
  return drop_rec ([position, lst1, (list([]) as big_array<T>)]);
};

//
// take retrieves first elements
//
export const take : <T>((p: [nat, big_array<T>]) => big_array<T>) = ([i, lst] : [nat, big_array<T>]) : big_array<T> => {
  let take_rec : <T>((p: [nat, big_array<T>, big_array<T>]) => big_array<T>) = ([i, lst, res] : [nat, big_array<T>, big_array<T>]) : big_array<T> => {
    if (i == (0 as nat) ) {
      return reverse(res);
    } else {
      return match(lst, list([
        ( [] : big_array<T>) => { reverse(res) },
        ( [hd1, ...tl1] : big_array<T>) => { take_rec( [abs(i-(1 as nat)), tl1, list([hd1, ...res]) ] ) }
      ]));
    };
  };
  return take_rec( [i, lst, (list([]) as big_array<T>)] );
};

//
// Slice extracts a sub big array at a specifc position (and a specific length)
//
export const slice : <T>((p: [nat, nat, big_array<T>]) => big_array<T>) = ([i, k, lst] : [nat, nat, big_array<T>]) : big_array<T> => {
  let slice_rec : <T>((pp: [nat, nat, big_array<T>]) => big_array<T>) = ([i, k, lst] : [nat, nat, big_array<T>]) : big_array<T> => {
    if (i == (0 as nat) ) { 
      let extract : nat = abs(k-i);
      return take( [extract, lst] );
    } else {
      return match(lst, list([
      ( [] : big_array<T>) => list([]),
      ( [_hd1, ...tl1] : big_array<T>) => slice_rec( [abs(i-(1 as nat)), k, tl1])
      ]));
    }
  };
  return slice_rec( [i, k, lst] );
};

//
// Split a given big array at a specific position
//
export const split : <T>((p: [nat, big_array<T>]) => [big_array<T>, big_array<T>]) = ([i, lst] : [nat, big_array<T>]) : [big_array<T>, big_array<T>] => {
  let split_rec : <T>((p: [nat, big_array<T>, big_array<T>]) => [big_array<T>, big_array<T>]) = ([i, lst1, lst2]: [nat, big_array<T>, big_array<T>]) : [big_array<T>, big_array<T>] => {
    if (i == (0 as nat) ) { 
      let lstr = reverse(lst2);
      return [lstr, lst1];
    } else {
      return match(lst1, list([
        ( [] : big_array<T>) => {
          let lstr = reverse(lst2);
          return [lstr, lst1];
        },
        ( [hd1, ...tl1] : big_array<T>) => {
          return split_rec( [abs(i-(1 as nat)), tl1, list([hd1, ...lst2]) ] );
        }
      ]));
    }
  };
  return split_rec ( [i, lst, (list([]) as big_array<T>)] );
};

//
// Rotate to the left
//
export const rotate : <T>((p: [nat, big_array<T>]) => big_array<T>) = ([i, lst] : [nat, big_array<T>]) : big_array<T> => {
  let rotate_rec : <T>((pp: [nat, big_array<T>, big_array<T>]) => big_array<T>) = ([i, lst, res] : [nat, big_array<T>, big_array<T>]) : big_array<T> => {
    if (i == (0 as nat) ) { 
      let lstr = reverse(res);
      return concat(lst, lstr);
    } else { 
      return match(lst, list([
      ( [] : big_array<T>) => { return reverse(res) },
      ( [hd1, ...tl1] : big_array<T>) => { return rotate_rec( [ abs(i- (1 as nat)), tl1, list([hd1, ...res]) ] ) }
      ]));
    }
  };
  return rotate_rec (i, lst, (list([]) as big_array<T>))
};

// equal (bytes version)
// WARNING : Two lambda can be packed equal whereas they are different
//
export const equal : <T>((p: [T, T]) => bool) = ([val_a, val_b]: [T, T]) : bool => {
    (Bytes.pack(val_a)) == (Bytes.pack(val_b))
};

//
// Remove all occurences of a given element
//
export const remove : <T>((p: [T, big_array<T>]) => big_array<T>) = ([element, lst] : [T, big_array<T>]) : big_array<T> => {
  let remove_rec : <T>((pp: [T, big_array<T>, big_array<T>]) => big_array<T>) = ([element, lst, res] : [T, big_array<T>, big_array<T>]) : big_array<T> => {
    return match(lst, list([
      ( [] : big_array<T>) => { return reverse(res) },
      ( [hd1, ...tl1] : big_array<T>) => {
        let is_equal = equal(hd1, element);
        if (is_equal) { 
          return remove_rec([element, tl1, res]);
        } else {
          return remove_rec([element, tl1, list([hd1, ...res])]) 
        }
      }
    ]));
  };
  return remove_rec( [element, lst, (list([]) as big_array<T>)] );
};

